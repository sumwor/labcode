%% ----- readDiscrimLogfile: read Presentation logfiles and parse it

% which figures are we going to generate
plotFig1=1;     %plot episodes aligned by start
episodeStart=-1;    %plot range for Fig1
episodeEnd=7;
plotFig1a=1;    %plot performance, running-average
plotFig2=1;     %plot episodes as rows of symbols
plotFig3=1;     %histogram of lick times
plotFig4=1;     %plot duration of trials
plotFig5=1;     %plot consecutive trials with the same stimulus

%% ----- set up figure plotting
set(groot, ...
    'DefaultFigureColor', 'w', ...
    'DefaultAxesLineWidth', 2, ...
    'DefaultAxesXColor', 'k', ...
    'DefaultAxesYColor', 'k', ...
    'DefaultAxesFontUnits', 'points', ...
    'DefaultAxesFontSize', 18, ...
    'DefaultAxesFontName', 'Helvetica', ...
    'DefaultLineLineWidth', 1, ...
    'DefaultTextFontUnits', 'Points', ...
    'DefaultTextFontSize', 18, ...
    'DefaultTextFontName', 'Helvetica', ...
    'DefaultAxesBox', 'off', ...
    'DefaultAxesTickLength', [0.02 0.025]);

% set the tick marks on figures to point outwards - need to set(groot) in this specific order
set(groot, 'DefaultAxesTickDir', 'out');
set(groot, 'DefaultAxesTickDirMode', 'manual');
set(0,'defaultfigureposition',[40 40 1000 1000]);

%% ----- create directory to save figure output
savefigpath = [newroot_dir 'figs-beh/'];
if ~exist(savefigpath,'dir')
    mkdir(savefigpath);
end

%% ----- the event codes defined in Neurobs Presentation
RESPONSE_LICKLEFT=2;
RESPONSE_LICKRIGHT=3;
CODE_LEFTSTIM=1;    %upsweep tone
CODE_RIGHTSTIM=2;   %downsweep tone
CODE_REWARDLEFT=3;
CODE_TIMEOUT=4;     %following error
CODE_STARTEXPT=5;
CODE_PAUSE=6;       %following miss
CODE_ENDEXPT=7;
CODE_REWARDRIGHT=8;

CODE_RESPONSELEFT=9;    %response window, if not overlapping with stimulus
CODE_RESPONSERIGHT=10;

CODE_LEFTSET_LEFTSTIM=9;    %for the flexibility task
CODE_LEFTSET_RIGHTSTIM=10;
CODE_RIGHTSET_LEFTSTIM=11;
CODE_RIGHTSET_RIGHTSTIM=12;

%some of the tasks deliver zero or double reward probabilistically
CODE_2XREWARDLEFT=13;      %10% correct responses-->2x Reward
CODE_2XREWARDRIGHT=14;
CODE_FALSETIMEOUT=15;      %10% correct responses-->0x Reward (OLD PRESENTATION SCRIPT did not designate left or right)
CODE_0XREWARDLEFT=16;      %10% correct responses-->0x Reward (new script does)
CODE_0XREWARDRIGHT=17;
CODE_INTERPULSE=18;        %10% correct responses-->2x Reward (revised script uses 2 pulses intead of twice duration to deliver double reward)

%% ----- parse the .log file generated by Neurobs Presentation
responseTime=[]; responseCode=[]; lickleftTime=[]; lickrightTime=[];
eventTime=[]; eventDur=[]; eventCode=[];
cd(newroot_dir);

%load the header lines of the behavioral log file
fid=fopen(strcat(newroot_dir,behavFile));
headerline1 = textscan(fid,'%s %c %s',1);
headerline2 = textscan(fid,'%s %s %c %s %s',1);
textscan(fid,'%s',1);
headerline4 = textscan(fid,'%s %s %s %s %s %s %s %s %s %s %s',1);
headerline6 = textscan(fid,'%s %s %s %s %s %s %s',1);
while strcmp(headerline6{3},'Manual')==0
    headerline6 = textscan(fid,'%s %s %s %s %s %s %s',1);
end
scenarioName=headerline1{3}{1};
startDate=headerline6{4}{1};
startTime=headerline6{5}{1};
endDate=headerline2{4}{1};
endTime=headerline2{5}{1};

%load line-by-line the behavioral log file
D = textscan(fid,'%s %u %s %d %d %*[^\n]','delimiter','\t','EmptyValue',-1);
%D = textscan(fid,'%s %u %s %d %d %u %u %u %u %u %s',-1); %for an obsolete version of Presentation
fclose(fid);

subject=D{1}{1};
disp(' ');
disp('------------------------');
disp(['Subject: ' subject]);
disp(['Recorded on: ' headerline6{4}{1} ' ' headerline6{5}{1} ' - ' headerline2{5}{1}]);
disp(['Analyzing file: ' behavFile]);

trialIndex=cumsum(D{4}==CODE_STARTEXPT);
trialStartIndex=1;
trialEndIndex=length(trialIndex);

%SST data set; 141026 R7/
trialEndIndex=sum(trialIndex<=200); %waitfor(errordlg('Manually setting the last trial to analysis. Remember to revert back'));

Time=double(D{5}(trialStartIndex:trialEndIndex))/10000;
if isempty(eventTime)
    Time=Time-Time(1);      %so time starts at zero
else
    Time=Time-Time(1)+eventTime(end)+eventDur(end); %append to the last trial
end
Code=double(D{4}(trialStartIndex:trialEndIndex));

%find out when Presentation has an event -- e.g. stimulus, reward, etc.
pictureIndex=strcmp(D{3}(trialStartIndex:trialEndIndex),'Nothing');
soundIndex=strcmp(D{3}(trialStartIndex:trialEndIndex),'Sound');
eventIndex=(pictureIndex | soundIndex);
eventTime=[eventTime; Time(eventIndex)];
eventCode=[eventCode; Code(eventIndex)];
eventDur=diff(eventTime);       %using diff is more accurate than using logfile's Duration
eventDur=[eventDur; 1/10000];

%find when animals make a tongue lick
responseIndex=strcmp(D{3}(trialStartIndex:trialEndIndex),'Response');
responseTime=[responseTime; Time(responseIndex)];
responseCode=[responseCode; Code(responseIndex)];
lickleftIndex=(responseCode==RESPONSE_LICKLEFT);
lickleftTime=[lickleftTime; responseTime(lickleftIndex)];
lickrightIndex=(responseCode==RESPONSE_LICKRIGHT);
lickrightTime=[lickrightTime; responseTime(lickrightIndex)];
lickTime=sort([lickleftTime; lickrightTime]);

%find when each trial begins
startexptIndex=(eventCode==CODE_STARTEXPT);
startexptTime=eventTime(startexptIndex);
startexptDur=nanmean(eventDur(startexptIndex)); %duration of startexpt -- basically time between startexpt and cue onset
disp(['Total number of trials: ' int2str(numel(startexptTime))]);

clear headerline1 headerline2 headerline4 headerline6;
clear D responseIndex lickleftIndex lickrightIndex rewardleftIndex pictureIndex soundIndex eventIndex startexptIndex targetIndex;
clear Time Code Dur;

%% ----- find the most successful trials for the session

hit_miss=[]; %a vector identifying the trial classification (coded according to below)
CODE_HITLEFT=1; CODE_INCORRECTLEFT=0; CODE_MISSLEFT=4; CODE_HITRIGHT=2; CODE_INCORRECTRIGHT=3; CODE_MISSRIGHT=5;

%for flexiblity task
CODE_PERSEVERLEFT=6; CODE_PERSEVERRIGHT=7; CODE_PERSEVERHITLEFT=8; CODE_PERSEVERHITRIGHT=9;
CODE_RIGHTSET_LEFTSTIM_HIT=11; CODE_RIGHTSET_LEFTSTIM_MISS=10; CODE_RIGHTSET_PERSEVERERR=12; CODE_RIGHTSET_INCORRECT=13; CODE_RIGHTSET_RIGHTSTIM_HIT=14; CODE_RIGHTSET_RIGHTSTIM_MISS=15;
CODE_LEFTSET_LEFTSTIM_HIT=21; CODE_LEFTSET_LEFTSTIM_MISS=20; CODE_LEFTSET_PERSEVERERR=22; CODE_LEFTSET_INCORRECT=23; CODE_LEFTSET_RIGHTSTIM_HIT=24; CODE_LEFTSET_RIGHTSTIM_MISS=25;

%for double reward task
CODE_HITLEFTDOUBLE=-1; CODE_HITRIGHTDOUBLE=-2; CODE_HITLEFTZERO=-3; CODE_HITRIGHTZERO=-4;

firstRespTime=[]; %a vector containing time between cue onset and reward delivery for each trial

currSet=[]; lastSet=[]; %a vector containing the current rule of the trial
CODE_CUE=0; CODE_ACTIONLEFT=1; CODE_ACTIONRIGHT=2;

%go through the eventCode's one by one to classify the trials
for i=1:(length(eventCode)-2)
    if eventCode(i)==CODE_LEFTSTIM
        currSet=[currSet CODE_CUE];             %currSet takes 0,1,or 2; sound, action_L, action_R
        if numel(currSet)>1
            if currSet(end-1)~=currSet(end)
                lastSet=currSet(end-1);
            end
        end
        if eventCode(i+1)==CODE_REWARDLEFT      %reward left follows low tone
            if lastSet==CODE_ACTIONLEFT
                hit_miss=[hit_miss CODE_PERSEVERHITLEFT];   %HIT
            else
                hit_miss=[hit_miss CODE_HITLEFT];           %HIT
            end
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        elseif eventCode(i+1)==CODE_TIMEOUT
            if lastSet==CODE_ACTIONRIGHT
                hit_miss=[hit_miss CODE_PERSEVERLEFT];  %PERSEVERATIVE ERROR
            else
                hit_miss=[hit_miss CODE_INCORRECTLEFT]; %INCORRECT
            end
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        elseif eventCode(i+1)==CODE_2XREWARDLEFT || eventCode(i+1)==CODE_INTERPULSE
            hit_miss=[hit_miss CODE_HITLEFTDOUBLE];   %HIT with double reward
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        elseif eventCode(i+1)==CODE_FALSETIMEOUT || eventCode(i+1)==CODE_0XREWARDLEFT
            hit_miss=[hit_miss CODE_HITLEFTZERO];     %HIT with zero reward
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        elseif eventCode(i+1)==CODE_ENDEXPT || eventCode(i+1)==CODE_PAUSE
            hit_miss=[hit_miss CODE_MISSLEFT];  %MISS
            firstRespTime=[firstRespTime nan];
        else
            hit_miss=[hit_miss nan];
            firstRespTime=[firstRespTime nan];
            disp(['Trial associated with stimulus #' int2str(i) ' could not be classified properly.']);
        end
    elseif eventCode(i)==CODE_RIGHTSTIM
        currSet=[currSet CODE_CUE];
        if numel(currSet)>1
            if currSet(end-1)~=currSet(end)
                lastSet=currSet(end-1);
            end
        end
        if eventCode(i+1)==CODE_REWARDRIGHT     %reward right follows high tone
            if lastSet==CODE_ACTIONRIGHT
                hit_miss=[hit_miss CODE_PERSEVERHITRIGHT];   %HIT
            else
                hit_miss=[hit_miss CODE_HITRIGHT];           %HIT
            end
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        elseif eventCode(i+1)==CODE_TIMEOUT
            if lastSet==CODE_ACTIONLEFT
                hit_miss=[hit_miss CODE_PERSEVERRIGHT];  %PERSEVERATIVE ERROR
            else
                hit_miss=[hit_miss CODE_INCORRECTRIGHT]; %INCORRECT
            end
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        elseif eventCode(i+1)==CODE_2XREWARDRIGHT || eventCode(i+1)==CODE_INTERPULSE
            hit_miss=[hit_miss CODE_HITRIGHTDOUBLE];   %HIT with double reward
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        elseif eventCode(i+1)==CODE_FALSETIMEOUT || eventCode(i+1)==CODE_0XREWARDRIGHT
            hit_miss=[hit_miss CODE_HITRIGHTZERO];     %HIT with zero reward
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        elseif eventCode(i+1)==CODE_ENDEXPT || eventCode(i+1)==CODE_PAUSE
            hit_miss=[hit_miss CODE_MISSRIGHT];  %MISS
            firstRespTime=[firstRespTime nan];
        else
            hit_miss=[hit_miss nan];
            firstRespTime=[firstRespTime nan];
            disp(['Trial associated with stimulus #' int2str(i) ' could not be classified properly.']);
        end
    elseif eventCode(i)==CODE_LEFTSET_LEFTSTIM
        currSet=[currSet CODE_ACTIONLEFT];
        if numel(currSet)>1
            if currSet(end-1)~=currSet(end)
                lastSet=currSet(end-1);
            end
        end
        if eventCode(i+1)==CODE_REWARDLEFT     %reward right
            hit_miss=[hit_miss CODE_LEFTSET_LEFTSTIM_HIT];  %HIT
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        elseif eventCode(i+1)==CODE_ENDEXPT || eventCode(i+1)==CODE_PAUSE
            hit_miss=[hit_miss CODE_LEFTSET_LEFTSTIM_MISS];  %MISS
            firstRespTime=[firstRespTime nan];
        elseif eventCode(i+1)==CODE_TIMEOUT
            hit_miss=[hit_miss CODE_LEFTSET_INCORRECT];%INCORRECT
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        else
            hit_miss=[hit_miss nan];
            firstRespTime=[firstRespTime nan];
            disp(['Trial associated with stimulus #' int2str(i) ' could not be classified properly.']);
        end
    elseif eventCode(i)==CODE_LEFTSET_RIGHTSTIM
        currSet=[currSet CODE_ACTIONLEFT];
        if numel(currSet)>1
            if currSet(end-1)~=currSet(end)
                lastSet=currSet(end-1);
            end
        end
        if eventCode(i+1)==CODE_REWARDLEFT      %reward right
            hit_miss=[hit_miss CODE_LEFTSET_RIGHTSTIM_HIT];   %HIT
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        elseif eventCode(i+1)==CODE_ENDEXPT || eventCode(i+1)==CODE_PAUSE
            hit_miss=[hit_miss CODE_LEFTSET_RIGHTSTIM_MISS];  %MISS
            firstRespTime=[firstRespTime nan];
        elseif eventCode(i+1)==CODE_TIMEOUT
            hit_miss=[hit_miss CODE_LEFTSET_PERSEVERERR];%PERSEVERATIVE ERROR
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        else
            hit_miss=[hit_miss nan];
            firstRespTime=[firstRespTime nan];
            disp(['Trial associated with stimulus #' int2str(i) ' could not be classified properly.']);
        end
    elseif eventCode(i)==CODE_RIGHTSET_LEFTSTIM
        currSet=[currSet CODE_ACTIONRIGHT];
        if numel(currSet)>1
            if currSet(end-1)~=currSet(end)
                lastSet=currSet(end-1);
            end
        end
        if eventCode(i+1)==CODE_REWARDRIGHT     %reward right
            hit_miss=[hit_miss CODE_RIGHTSET_LEFTSTIM_HIT];  %HIT
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        elseif eventCode(i+1)==CODE_ENDEXPT || eventCode(i+1)==CODE_PAUSE
            hit_miss=[hit_miss CODE_RIGHTSET_LEFTSTIM_MISS];  %MISS
            firstRespTime=[firstRespTime nan];
        elseif eventCode(i+1)==CODE_TIMEOUT
            hit_miss=[hit_miss CODE_RIGHTSET_PERSEVERERR];%PERSEVERATIVE ERROR
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        else
            hit_miss=[hit_miss nan];
            firstRespTime=[firstRespTime nan];
            disp(['Trial associated with stimulus #' int2str(i) ' could not be classified properly.']);
        end
    elseif eventCode(i)==CODE_RIGHTSET_RIGHTSTIM
        currSet=[currSet CODE_ACTIONRIGHT];
        if numel(currSet)>1
            if currSet(end-1)~=currSet(end)
                lastSet=currSet(end-1);
            end
        end
        if eventCode(i+1)==CODE_REWARDRIGHT      %reward right
            hit_miss=[hit_miss CODE_RIGHTSET_RIGHTSTIM_HIT];   %HIT
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        elseif eventCode(i+1)==CODE_ENDEXPT || eventCode(i+1)==CODE_PAUSE
            hit_miss=[hit_miss CODE_RIGHTSET_RIGHTSTIM_MISS];  %MISS
            firstRespTime=[firstRespTime nan];
        elseif eventCode(i+1)==CODE_TIMEOUT
            hit_miss=[hit_miss CODE_RIGHTSET_INCORRECT];%INCORRECT
            firstRespTime=[firstRespTime eventTime(i+1)-eventTime(i)];
        else
            hit_miss=[hit_miss nan];
            firstRespTime=[firstRespTime nan];
            disp(['Trial associated with stimulus #' int2str(i) ' could not be classified properly.']);
        end
    end
end

%if last trial is incomplete, crop it
if (numel(startexptTime)-1)==numel(firstRespTime)
    startexptTime=startexptTime(1:end-1);
end

%do run-length encoding on currSet to find out when the rule shifts occurred
len=diff([0 find(currSet(1:end-1) ~= currSet(2:end)) length(currSet)]);
val=currSet([find(currSet(1:end-1) ~= currSet(2:end)) length(currSet)]);
switchTrial=[];
for i=1:length(len)-1
    switchTrial(i)=sum(len(1:i))+1; %the first trial when new rule is applied
end
currTrial=val;

% estimate response time -- look for licks after cue onset,
% but exclude those if there are preceding licks (i.e. animals already
% licking before cue onset)
firstLickTime=nan(1,numel(hit_miss));
for j=1:numel(hit_miss)
    templickTime=lickTime-(startexptTime(j)+startexptDur);
    %no licks for 0.5 s before cue, and first lick occurs within 1 s
    if (max(templickTime(templickTime<=0)) < -0.5) & (min(templickTime(templickTime>0)) < 1)
        firstLickTime(j)=min(templickTime(templickTime>0));
    else
        firstLickTime(j)=NaN;
    end
end

%% ----- create a mask for certain trial types

trialMask=[];

%factor = cue: upsweep or downsweep?
trialMask.upsweep=(hit_miss==CODE_HITLEFT | hit_miss==CODE_HITLEFTDOUBLE | hit_miss==CODE_HITLEFTZERO | hit_miss==CODE_PERSEVERHITLEFT | hit_miss==CODE_INCORRECTLEFT | hit_miss==CODE_PERSEVERLEFT | hit_miss==CODE_LEFTSET_LEFTSTIM_HIT | hit_miss==CODE_RIGHTSET_LEFTSTIM_HIT | hit_miss==CODE_RIGHTSET_PERSEVERERR | hit_miss==CODE_LEFTSET_INCORRECT | hit_miss==CODE_MISSLEFT | hit_miss==CODE_LEFTSET_LEFTSTIM_MISS | hit_miss==CODE_RIGHTSET_LEFTSTIM_MISS);
trialMask.downsweep=(hit_miss==CODE_HITRIGHT | hit_miss==CODE_HITRIGHTDOUBLE | hit_miss==CODE_HITRIGHTZERO | hit_miss==CODE_PERSEVERHITRIGHT | hit_miss==CODE_INCORRECTRIGHT | hit_miss==CODE_PERSEVERRIGHT | hit_miss==CODE_LEFTSET_RIGHTSTIM_HIT | hit_miss==CODE_RIGHTSET_RIGHTSTIM_HIT | hit_miss==CODE_LEFTSET_PERSEVERERR | hit_miss==CODE_RIGHTSET_INCORRECT | hit_miss==CODE_MISSRIGHT | hit_miss==CODE_LEFTSET_RIGHTSTIM_MISS | hit_miss==CODE_RIGHTSET_RIGHTSTIM_MISS);
if numel(hit_miss) ~= sum(trialMask.upsweep)+sum(trialMask.downsweep)
    disp('Error: #trials for upsweep and downsweep do not add up');
end

%factor = outcome: hit or incorrect?
trialMask.hit=(hit_miss==CODE_HITLEFT | hit_miss==CODE_PERSEVERHITLEFT | hit_miss==CODE_HITRIGHT | hit_miss==CODE_PERSEVERHITRIGHT | hit_miss==CODE_LEFTSET_LEFTSTIM_HIT | hit_miss==CODE_RIGHTSET_LEFTSTIM_HIT | hit_miss==CODE_LEFTSET_RIGHTSTIM_HIT | hit_miss==CODE_RIGHTSET_RIGHTSTIM_HIT | hit_miss==CODE_HITLEFTDOUBLE | hit_miss==CODE_HITLEFTZERO | hit_miss==CODE_HITRIGHTDOUBLE | hit_miss==CODE_HITRIGHTZERO);
trialMask.error=(hit_miss==CODE_INCORRECTLEFT | hit_miss==CODE_INCORRECTRIGHT | hit_miss==CODE_PERSEVERLEFT | hit_miss==CODE_PERSEVERRIGHT | hit_miss==CODE_LEFTSET_PERSEVERERR | hit_miss==CODE_LEFTSET_INCORRECT | hit_miss==CODE_RIGHTSET_PERSEVERERR | hit_miss==CODE_RIGHTSET_INCORRECT);
trialMask.miss=(hit_miss==CODE_MISSLEFT | hit_miss==CODE_MISSRIGHT | hit_miss==CODE_RIGHTSET_LEFTSTIM_MISS | hit_miss==CODE_RIGHTSET_RIGHTSTIM_MISS | hit_miss==CODE_LEFTSET_LEFTSTIM_MISS | hit_miss==CODE_LEFTSET_RIGHTSTIM_MISS);
trialMask.pererror=(hit_miss==CODE_PERSEVERLEFT | hit_miss==CODE_PERSEVERRIGHT | hit_miss==CODE_LEFTSET_PERSEVERERR | hit_miss==CODE_RIGHTSET_PERSEVERERR);
trialMask.otherror=(hit_miss==CODE_INCORRECTLEFT | hit_miss==CODE_INCORRECTRIGHT | hit_miss==CODE_LEFTSET_INCORRECT | hit_miss==CODE_RIGHTSET_INCORRECT);
trialMask.perhit=(hit_miss==CODE_PERSEVERHITLEFT | hit_miss==CODE_PERSEVERHITRIGHT);
if numel(hit_miss) ~= sum(trialMask.hit)+sum(trialMask.error)+sum(trialMask.miss)
    disp('Error: #trials for hit, error, and miss do not add up');
end

%factor = action: left or right?
trialMask.left=(hit_miss==CODE_HITLEFT | hit_miss==CODE_HITLEFTDOUBLE | hit_miss==CODE_HITLEFTZERO| hit_miss==CODE_PERSEVERHITLEFT | hit_miss==CODE_INCORRECTRIGHT | hit_miss==CODE_PERSEVERRIGHT | hit_miss==CODE_LEFTSET_LEFTSTIM_HIT | hit_miss==CODE_LEFTSET_RIGHTSTIM_HIT | hit_miss==CODE_RIGHTSET_PERSEVERERR | hit_miss==CODE_RIGHTSET_INCORRECT);
trialMask.right=(hit_miss==CODE_HITRIGHT | hit_miss==CODE_HITRIGHTDOUBLE | hit_miss==CODE_HITRIGHTZERO | hit_miss==CODE_PERSEVERHITRIGHT | hit_miss==CODE_INCORRECTLEFT | hit_miss==CODE_PERSEVERLEFT | hit_miss==CODE_RIGHTSET_LEFTSTIM_HIT | hit_miss==CODE_RIGHTSET_RIGHTSTIM_HIT | hit_miss==CODE_LEFTSET_PERSEVERERR | hit_miss==CODE_LEFTSET_INCORRECT);
if numel(hit_miss) ~= sum(trialMask.left)+sum(trialMask.right)+sum(trialMask.miss)
    disp('Error: #trials for left, right, and miss do not add up');
end

%outcome/action of last trial
trialMask.lasthit=logical([0 trialMask.hit(1:end-1)]);
trialMask.lastmiss=logical([0 trialMask.miss(1:end-1)]);
trialMask.lastleft=logical([0 trialMask.left(1:end-1)]);
trialMask.lastright=logical([0 trialMask.right(1:end-1)]);

trialMask.lastlastleft=logical([0 0 trialMask.left(1:end-2)]);
trialMask.lastlastright=logical([0 0 trialMask.right(1:end-2)]);

%factor = rule: sound or action?
trialMask.sound=(currSet==CODE_CUE);
trialMask.action=(currSet==CODE_ACTIONLEFT | currSet==CODE_ACTIONRIGHT);
trialMask.actionleft=(currSet==CODE_ACTIONLEFT);
trialMask.actionright=(currSet==CODE_ACTIONRIGHT);
if numel(hit_miss) ~= sum(trialMask.sound)+sum(trialMask.actionleft)+sum(trialMask.actionright)
    disp('Error: #trials for sound, action-left, action-right do not add up');
end

%factor = rule: sound or action? pick out 20 trials before and after switches of various types
trialMask.soundPreSwitch=false(size(hit_miss));
trialMask.soundAfterLeftPreSwitch=false(size(hit_miss)); trialMask.soundAfterRightPreSwitch=false(size(hit_miss));
trialMask.actionPreSwitch=false(size(hit_miss));
trialMask.actionleftPreSwitch=false(size(hit_miss)); trialMask.actionrightPreSwitch=false(size(hit_miss));
trialMask.soundPostSwitch=false(size(hit_miss));
trialMask.soundAfterLeftPostSwitch=false(size(hit_miss)); trialMask.soundAfterRightPostSwitch=false(size(hit_miss));
trialMask.actionPostSwitch=false(size(hit_miss));
trialMask.actionleftPostSwitch=false(size(hit_miss)); trialMask.actionrightPostSwitch=false(size(hit_miss));

if ~isempty(switchTrial)
    
    %trial mask for trials after rule switches
    
    %first rule switch
    endIdx=min([switchTrial(1)+19 numel(hit_miss)]);
    if currTrial(2)==CODE_ACTIONLEFT
        trialMask.actionleftPostSwitch(switchTrial(1):endIdx)=true;
    elseif currTrial(2)==CODE_ACTIONRIGHT
        trialMask.actionrightPostSwitch(switchTrial(1):endIdx)=true;
    end
    %subsequent rule switches
    for i=2:numel(switchTrial)
        startIdx=switchTrial(i)-20;
        endIdx=min([switchTrial(i)+19 numel(hit_miss)]);
        if currTrial(i)==CODE_CUE && currTrial(i+1)==CODE_ACTIONLEFT
            trialMask.soundAfterRightPreSwitch(startIdx:switchTrial(i)-1)=true; %pre-switch trials in a sound block, preceding block is action-right
            trialMask.actionleftPostSwitch(switchTrial(i):endIdx)=true;
        elseif currTrial(i)==CODE_CUE && currTrial(i+1)==CODE_ACTIONRIGHT
            trialMask.soundAfterLeftPreSwitch(startIdx:switchTrial(i)-1)=true;
            trialMask.actionrightPostSwitch(switchTrial(i):endIdx)=true;
        elseif currTrial(i)==CODE_ACTIONLEFT && currTrial(i+1)==CODE_CUE
            trialMask.actionleftPreSwitch(startIdx:switchTrial(i)-1)=true;
            trialMask.soundAfterLeftPostSwitch(switchTrial(i):endIdx)=true;
        elseif currTrial(i)==CODE_ACTIONRIGHT && currTrial(i+1)==CODE_CUE
            trialMask.actionrightPreSwitch(startIdx:switchTrial(i)-1)=true;
            trialMask.soundAfterRightPostSwitch(switchTrial(i):endIdx)=true;
        end
    end
    trialMask.soundPreSwitch=trialMask.soundAfterLeftPreSwitch | trialMask.soundAfterRightPreSwitch;
    trialMask.soundPostSwitch=trialMask.soundAfterLeftPostSwitch | trialMask.soundAfterRightPostSwitch;
    trialMask.actionPreSwitch=trialMask.actionleftPreSwitch | trialMask.actionrightPreSwitch;
    trialMask.actionPostSwitch=trialMask.actionrightPostSwitch | trialMask.actionleftPostSwitch;
    
    %mask that excludes trials from the last incomplete block
    trialMask.excludelastblock=[true(1,switchTrial(end)-1) false(1,numel(hit_miss)-switchTrial(end)+1)];
    %mask that excludes trials from the first block, before rule switching is imposed on animal
    trialMask.excludefirstblock=[false(1,switchTrial(1)-1) true(1,numel(hit_miss)-switchTrial(1)+1)];
    
    %decompose sound blocks by noting whether it is followed by an
    %action-left or action-right block
    trialMask.soundAfterAL=false(size(hit_miss));
    trialMask.soundAfterAR=false(size(hit_miss));
    for i=2:numel(currTrial)-1
        %this excludes the first sound block, as first block it is not after any action block
        %also excludes last block, as last block it is incomplete and not sure if animal adjusted
        startTrial=switchTrial(i-1);
        endTrial=switchTrial(i)-1;
        
        if currTrial(i)==CODE_CUE && currTrial(i-1)==CODE_ACTIONLEFT
            trialMask.soundAfterAL(startTrial:endTrial)=true;
        elseif currTrial(i)==CODE_CUE && currTrial(i-1)==CODE_ACTIONRIGHT
            trialMask.soundAfterAR(startTrial:endTrial)=true;
        end
    end
end

%% ----- create a mask for certain block types

blockMask=[]; %excludes the last incomplete block

if ~isempty(switchTrial)
    blockMask.all=true(1,numel(currTrial)-1);
    blockMask.sound=(currTrial(1:end-1)==CODE_CUE);
    blockMask.actionleft=(currTrial(1:end-1)==CODE_ACTIONLEFT);
    blockMask.actionright=(currTrial(1:end-1)==CODE_ACTIONRIGHT);
    blockMask.action=blockMask.actionleft | blockMask.actionright;
    
    blockMask.excludefirstblock=[false(1,1) true(1,numel(currTrial)-2)];
end

%% ----- display a basic summary of performance on Matlab command line
disp(['--- Performance ---']);
disp(['# hits: ' int2str(sum(trialMask.hit))]);
disp(['# perseverative error: ' int2str(sum(trialMask.pererror))]);
disp(['# other error: ' int2str(sum(trialMask.otherror))]);
disp(['# miss: ' int2str(sum(trialMask.miss))]);
disp([' ']);
if numel(switchTrial)>0
    disp(['# rule shifts: ' int2str(numel(switchTrial))]);
else
    disp(['No rule shifts made.']);
end

%% ----- plot results graphically, aligned by event type

if (plotFig1)
    figure; hold on;
    title({['Mouse ' subject ' on ' startDate ' ' startTime(1:5) '-' endTime(1:5)];'{\color{blue}Up-sweep} {\color[rgb]{0.5 0.8 1}Down-sweep} {\color{green}Reward} {\color{magenta}Timeout} {\color{black}L Licks} {\color{red}R Licks}'});
    for i=1:length(startexptTime)
        if i>1      %if it's not first episode, also look at negative time as specified by episodeStart
            episodeIndex = eventTime > startexptTime(i)+episodeStart & eventTime < startexptTime(i)+episodeEnd;
        else
            episodeIndex = eventTime > startexptTime(i) & eventTime < startexptTime(i)+episodeEnd;
        end
        episodeIndexStart=find(episodeIndex,1,'first');     %getting the events that within [episodeStart, episodeEnd]
        episodeIndexEnd=find(episodeIndex,1,'last');     %getting the events that within [episodeStart, episodeEnd]
        clear episodeIndex;
        for j=episodeIndexStart:episodeIndexEnd
            switch eventCode(j)
                case CODE_LEFTSTIM
                    color='b';
                    p=fill([eventTime(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)-startexptTime(i)],[i-1 i-1 i i],color);
                    set(p,'Edgecolor',color);
                case CODE_RIGHTSTIM
                    color=[0.5 0.8 1];
                    p=fill([eventTime(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)-startexptTime(i)],[i-1 i-1 i i],color);
                    set(p,'Edgecolor',color);
                case CODE_LEFTSET_LEFTSTIM
                    color='b';
                    p=fill([eventTime(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)-startexptTime(i)],[i-1 i-1 i i],color);
                    set(p,'Edgecolor',color);
                case CODE_LEFTSET_RIGHTSTIM
                    color=[0.5 0.8 1];
                    p=fill([eventTime(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)-startexptTime(i)],[i-1 i-1 i i],color);
                    set(p,'Edgecolor',color);
                case CODE_RIGHTSET_LEFTSTIM
                    color='b';
                    p=fill([eventTime(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)-startexptTime(i)],[i-1 i-1 i i],color);
                    set(p,'Edgecolor',color);
                case CODE_RIGHTSET_RIGHTSTIM
                    color=[0.5 0.8 1];
                    p=fill([eventTime(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)-startexptTime(i)],[i-1 i-1 i i],color);
                    set(p,'Edgecolor',color);
                case CODE_REWARDLEFT
                    color='g';
                    p=fill([eventTime(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)-startexptTime(i)],[i-1 i-1 i i],color);
                    set(p,'Edgecolor',color);
                case CODE_REWARDRIGHT
                    color='g';
                    p=fill([eventTime(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)-startexptTime(i)],[i-1 i-1 i i],color);
                    set(p,'Edgecolor',color);
                case CODE_TIMEOUT
                    color='m';
                    p=fill([eventTime(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)+eventDur(j)-startexptTime(i) eventTime(j)-startexptTime(i)],[i-1 i-1 i i],color);
                    set(p,'Edgecolor',color);
            end
        end
        lickleftIndex = lickleftTime > startexptTime(i)+episodeStart & lickleftTime < startexptTime(i)+episodeEnd;
        plot([lickleftTime(lickleftIndex)-startexptTime(i) lickleftTime(lickleftIndex)-startexptTime(i)]',i-1+[zeros(size(lickleftTime(lickleftIndex))) ones(size(lickleftTime(lickleftIndex)))]','k');
        lickrightIndex = lickrightTime > startexptTime(i)+episodeStart & lickrightTime < startexptTime(i)+episodeEnd;
        plot([lickrightTime(lickrightIndex)-startexptTime(i) lickrightTime(lickrightIndex)-startexptTime(i)]',i-1+[zeros(size(lickrightTime(lickrightIndex))) ones(size(lickrightTime(lickrightIndex)))]','r');
    end
    plot([0 0],[0 length(startexptTime)],'k','LineWidth',1);
    for i=1:length(switchTrial)
        plot([episodeStart episodeEnd],switchTrial(i)*[1 1],'k');
    end
    axis([episodeStart,episodeEnd,0,length(startexptTime)]);
    set(gca, 'ydir','reverse')
    xlabel('Time (s)');
    ylabel('Trial');
    
    set(gcf,'Position',[40 40 600 800]);  %laptop
    set(gcf, 'PaperPositionMode', 'auto');
    print(gcf, '-r0', [savefigpath subject '_' startDate(9:10) startDate(1:2) startDate(4:5) '_' scenarioName], '-dpng'); %png format
end

%% ----- plot performance over a running average
if (plotFig1a)
    
    %quantify performance using a running average
    consecStim=10;          %conseuctive trials used for generated time-lapse hit rate plots
    bin_hitRateLeft=[]; bin_hitRateRight=[]; bin_hitRate=[]; bin_missfraction=[]; bin_persevererrfraction=[]; bin_othererrfraction=[]; bin_dprime=[]; %left and right hit rates in every n-stim bin
    for i=-consecStim+1:length(hit_miss)-consecStim
        endIdx=(i+consecStim-1);
        
        startIdx=i;
        %is startIdx trial near post-switch? if so, instead of using 10 prior trials, use prior trials up to switch only
        if startIdx<1
            startIdx=1;
        end
        tempHitLeft=sum(hit_miss(startIdx:endIdx)==CODE_HITLEFT)+sum(hit_miss(startIdx:endIdx)==CODE_PERSEVERHITLEFT)+sum(hit_miss(startIdx:endIdx)==CODE_LEFTSET_LEFTSTIM_HIT)+sum(hit_miss(startIdx:endIdx)==CODE_LEFTSET_RIGHTSTIM_HIT);
        tempIncorrLeft=sum(hit_miss(startIdx:endIdx)==CODE_INCORRECTLEFT)+sum(hit_miss(startIdx:endIdx)==CODE_PERSEVERLEFT)+sum(hit_miss(startIdx:endIdx)==CODE_LEFTSET_PERSEVERERR)+sum(hit_miss(startIdx:endIdx)==CODE_LEFTSET_INCORRECT);
        tempMissLeft=sum(hit_miss(startIdx:endIdx)==CODE_MISSLEFT)+sum(hit_miss(startIdx:endIdx)==CODE_LEFTSET_LEFTSTIM_MISS)+sum(hit_miss(startIdx:endIdx)==CODE_LEFTSET_RIGHTSTIM_MISS);
        tempHitRight=sum(hit_miss(startIdx:endIdx)==CODE_HITRIGHT)+sum(hit_miss(startIdx:endIdx)==CODE_PERSEVERHITRIGHT)+sum(hit_miss(startIdx:endIdx)==CODE_RIGHTSET_LEFTSTIM_HIT)+sum(hit_miss(startIdx:endIdx)==CODE_RIGHTSET_RIGHTSTIM_HIT);
        tempIncorrRight=sum(hit_miss(startIdx:endIdx)==CODE_INCORRECTRIGHT)+sum(hit_miss(startIdx:endIdx)==CODE_PERSEVERRIGHT)+sum(hit_miss(startIdx:endIdx)==CODE_RIGHTSET_PERSEVERERR)+sum(hit_miss(startIdx:endIdx)==CODE_RIGHTSET_INCORRECT);
        tempMissRight=sum(hit_miss(startIdx:endIdx)==CODE_MISSRIGHT)+sum(hit_miss(startIdx:endIdx)==CODE_RIGHTSET_LEFTSTIM_MISS)+sum(hit_miss(startIdx:endIdx)==CODE_RIGHTSET_RIGHTSTIM_MISS);
        tempPersevererr=sum(hit_miss(startIdx:endIdx)==CODE_LEFTSET_PERSEVERERR)+sum(hit_miss(startIdx:endIdx)==CODE_RIGHTSET_PERSEVERERR)+sum(hit_miss(startIdx:endIdx)==CODE_PERSEVERLEFT)+sum(hit_miss(startIdx:endIdx)==CODE_PERSEVERRIGHT);
        tempOthererr=sum(hit_miss(startIdx:endIdx)==CODE_LEFTSET_INCORRECT)+sum(hit_miss(startIdx:endIdx)==CODE_RIGHTSET_INCORRECT)+sum(hit_miss(startIdx:endIdx)==CODE_INCORRECTLEFT)+sum(hit_miss(startIdx:endIdx)==CODE_INCORRECTRIGHT);
        
        bin_hitRateLeft=[bin_hitRateLeft tempHitLeft/(tempHitLeft+tempIncorrLeft)];
        bin_hitRateRight=[bin_hitRateRight tempHitRight/(tempHitRight+tempIncorrRight)];
        bin_hitRate=[bin_hitRate (tempHitLeft+tempHitRight)/(tempHitLeft+tempIncorrLeft+tempHitRight+tempIncorrRight)];
        bin_missfraction=[bin_missfraction (tempMissLeft+tempMissRight)/(tempHitLeft+tempIncorrLeft+tempMissLeft+tempHitRight+tempIncorrRight+tempMissRight)];
        bin_persevererrfraction=[bin_persevererrfraction tempPersevererr/(tempHitLeft+tempIncorrLeft+tempHitRight+tempIncorrRight)];
        bin_othererrfraction=[bin_othererrfraction tempOthererr/(tempHitLeft+tempIncorrLeft+tempHitRight+tempIncorrRight)];
    end
    
    figure;
    for kk=1:5
        if kk==1
            temp=100*bin_hitRateLeft;
            ytitle='Left hit (%)';
        elseif kk==2
            temp=100*bin_hitRateRight;
            ytitle='Right hit (%)';
        elseif kk==3
            temp=100*bin_hitRate;
            ytitle='Hit (%)';
        elseif kk==4
            temp=100*bin_persevererrfraction;
            ytitle='P-error (%)';
        elseif kk==5
            temp=100*bin_othererrfraction;
            ytitle='O-error (%)';
        end
        
        subplot(5,1,kk); hold on;
        
        %color-code the rule blocks
        if ~isempty(switchTrial)
            for jj=1:numel(currTrial)
                if jj==1
                    x1=1; x2=switchTrial(1); y1=0; y2=105;
                elseif jj==numel(currTrial)
                    x1=switchTrial(end); x2=numel(trialMask.hit); y1=0; y2=105;
                else
                    x1=switchTrial(jj-1); x2=switchTrial(jj); y1=0; y2=105;
                end
                if currTrial(jj)==CODE_CUE
                    fill([x1 x1 x2 x2],[y1 y2 y2 y1],[0.8 0.8 0.8]);
                elseif currTrial(jj)==CODE_ACTIONLEFT
                    fill([x1 x1 x2 x2],[y1 y2 y2 y1],[1 0.8 0.8]);
                elseif currTrial(jj)==CODE_ACTIONRIGHT
                    fill([x1 x1 x2 x2],[y1 y2 y2 y1],[0.8 0.8 1]);
                end
                if jj<=numel(switchTrial)
                    plot(switchTrial(jj)*[1 1],[y1 y2],'Color',[0.5 0.5 0.5],'LineWidth',1);
                end
            end
        end
        
        %plot the running-average
        plot([1:length(hit_miss)],temp,'k','LineWidth',2);
        for i=1:length(switchTrial)
            plot(switchTrial(i)*[1 1],[0 100],'k');
        end
        
        axis([0 length(hit_miss) 0 105]);
        ylabel(ytitle);
        if kk==1
            title(['Running average of ' int2str(consecStim) ' trials']);
        end
    end
    
    set(gcf,'Position',[40 40 1000 1000]);  %laptop
    set(gcf, 'PaperPositionMode', 'auto');
    print(gcf, '-r0', [savefigpath subject '_' startDate(9:10) startDate(1:2) startDate(4:5) '_' scenarioName '_runningavg'], '-dtiff'); %tiff format
    saveas(gcf, [savefigpath subject '_' startDate(9:10) startDate(1:2) startDate(4:5) '_' scenarioName '_runningavg'], 'fig'); %fig format
end

%% ----- plot behavioral results as several rows of symbols
if (plotFig2)
    figure; hold on;
    %color-code the rule blocks
    if ~isempty(switchTrial)
        for jj=1:numel(currTrial)
            if jj==1
                x1=0; x2=switchTrial(1)-0.5; y1=-4; y2=4;
            elseif jj==numel(currTrial)
                x1=switchTrial(end)-0.5; x2=numel(trialMask.hit); y1=-4; y2=4;
            else
                x1=switchTrial(jj-1)-0.5; x2=switchTrial(jj)-0.5; y1=-4; y2=4;
            end
            if currTrial(jj)==CODE_CUE
                fill([x1 x1 x2 x2],[y1 y2 y2 y1],[0.8 0.8 0.8]);
            elseif currTrial(jj)==CODE_ACTIONLEFT
                fill([x1 x1 x2 x2],[y1 y2 y2 y1],[1 0.8 0.8]);
            elseif currTrial(jj)==CODE_ACTIONRIGHT
                fill([x1 x1 x2 x2],[y1 y2 y2 y1],[0.8 0.8 1]);
            end
            if jj<=numel(switchTrial)
                plot((switchTrial(jj)-0.5)*[1 1],[-4 4],'Color',[0.5 0.5 0.5],'LineWidth',1);
            end
        end
    end
    
    plot(find(trialMask.hit==1),3*ones(1,sum(trialMask.hit)),'k.','MarkerSize',15,'LineWidth',2);
    plot(find(trialMask.pererror==1),2*ones(1,sum(trialMask.pererror)),'ko','MarkerSize',10,'LineWidth',2);
    plot(find(trialMask.otherror==1),1*ones(1,sum(trialMask.otherror)),'k^','MarkerSize',10,'LineWidth',2);
    plot(find(trialMask.miss==1),0*ones(1,sum(trialMask.miss)),'kx','MarkerSize',10,'LineWidth',2);
    
    plot(find(trialMask.upsweep==1),-2*ones(1,sum(trialMask.upsweep)),'ko','MarkerSize',10,'LineWidth',2);
    plot(find(trialMask.downsweep==1),-3*ones(1,sum(trialMask.downsweep)),'ko','MarkerSize',10,'LineWidth',2);
    
    xlim([0 numel(trialMask.hit)]);
    ylim([-4 4]);
    set(gca,'yticklabel',{'Downsweep' 'Upsweep' 'Miss' 'O-err' 'P-err' 'Hit'},'ytick',[-3 -2 0:1:3]);
    xlabel('Trial');
    
    set(gcf,'Position',[40 40 2000 300]);  %laptop
    set(gcf, 'PaperPositionMode', 'auto');
    print(gcf, '-r0', [savefigpath subject '_' startDate(9:10) startDate(1:2) startDate(4:5) '_' scenarioName '_symbols'], '-dtiff'); %tiff format
    saveas(gcf, [savefigpath subject '_' startDate(9:10) startDate(1:2) startDate(4:5) '_' scenarioName '_symbols'], 'fig'); %fig format
end

%% ----- histogram of licking
if (plotFig3)
    edgeWidth=0.1;
    reactionWindowStart=-3;
    reactionWindowEnd=6;
    nedges=[reactionWindowStart:edgeWidth:reactionWindowEnd];
    
    nLeftUpsweep=[]; nRightUpsweep=[]; nLeftDownsweep=[]; nRightDownsweep=[];
    for kk=1:9
        if kk==1    %ALL sound trials
            trialIdx=find((trialMask.sound & trialMask.hit)==1);
        elseif kk==2    %ALL action left trials
            trialIdx=find((trialMask.actionleft & trialMask.hit)==1);
        elseif kk==3    %ALL action right trials
            trialIdx=find((trialMask.actionright & trialMask.hit)==1);
        elseif kk==4    %pre-switch sound trials
            trialIdx=find((trialMask.soundPreSwitch & trialMask.hit)==1);
        elseif kk==5    %pre-switch actionL trials
            trialIdx=find((trialMask.actionleftPreSwitch & trialMask.hit)==1);
        elseif kk==6    %pre-switch actionR trials
            trialIdx=find((trialMask.actionrightPreSwitch & trialMask.hit)==1);
        elseif kk==7    %post-switch sound trials
            trialIdx=find((trialMask.soundPostSwitch & trialMask.hit)==1);
        elseif kk==8    %post-switch actionL trials
            trialIdx=find((trialMask.actionleftPostSwitch & trialMask.hit)==1);
        elseif kk==9    %post-switch actionR trials
            trialIdx=find((trialMask.actionrightPostSwitch & trialMask.hit)==1);
        end
        
        rTimeLeftUpsweep=[]; rTimeRightUpsweep=[]; Upcount=0;
        rTimeLeftDownsweep=[]; rTimeRightDownsweep=[]; Downcount=0;
        for jj=1:numel(trialIdx)
            tempTime=startexptTime(trialIdx(jj))+startexptDur; %time of cue
            lickleftIndex = lickleftTime > tempTime+reactionWindowStart & lickleftTime < tempTime+reactionWindowEnd;
            lickrightIndex = lickrightTime > tempTime+reactionWindowStart & lickrightTime < tempTime+reactionWindowEnd;
            if trialMask.upsweep(trialIdx(jj))==1
                rTimeLeftUpsweep = [rTimeLeftUpsweep; lickleftTime(lickleftIndex)-tempTime];
                rTimeRightUpsweep = [rTimeRightUpsweep; lickrightTime(lickrightIndex)-tempTime];
                Upcount=Upcount+1;
            else
                rTimeLeftDownsweep = [rTimeLeftDownsweep; lickleftTime(lickleftIndex)-tempTime];
                rTimeRightDownsweep = [rTimeRightDownsweep; lickrightTime(lickrightIndex)-tempTime];
                Downcount=Downcount+1;
            end
        end
        
        if ~isempty(rTimeLeftUpsweep)
            nLeftUpsweep(:,kk)=histc(rTimeLeftUpsweep(rTimeLeftUpsweep<reactionWindowEnd),nedges)/Upcount/edgeWidth;  %take out the misses
        else
            nLeftUpsweep(:,kk)=nan(1,numel(nedges));
        end
        if ~isempty(rTimeRightUpsweep)
            nRightUpsweep(:,kk)=histc(rTimeRightUpsweep(rTimeRightUpsweep<reactionWindowEnd),nedges)/Upcount/edgeWidth;  %take out the misses
        else
            nRightUpsweep(:,kk)=nan(1,numel(nedges));
        end
        if ~isempty(rTimeLeftDownsweep)
            nLeftDownsweep(:,kk)=histc(rTimeLeftDownsweep(rTimeLeftDownsweep<reactionWindowEnd),nedges)/Downcount/edgeWidth;  %take out the misses
        else
            nLeftDownsweep(:,kk)=nan(1,numel(nedges));
        end
        if ~isempty(rTimeRightDownsweep)
            nRightDownsweep(:,kk)=histc(rTimeRightDownsweep(rTimeRightDownsweep<reactionWindowEnd),nedges)/Downcount/edgeWidth;  %take out the misses
        else
            nRightDownsweep(:,kk)=nan(1,numel(nedges));
        end
    end
    
    figure;
    for kk=1:3
        if kk==1 %all sound trials
            col='k';
        elseif kk==2 %all action left trials
            col='r';
        elseif kk==3 %all action right trials
            col='b';
        end
        
        subplot(2,6,1+(kk-1)*2); hold on;
        y=nLeftUpsweep(:,kk);
        plot(nedges,y,col,'LineWidth',2);
        plot([0 0],[0 12],'k--','LineWidth',1); xlim([-3 5]); ylim([0 12]);
        if kk==1
            ylabel('Upsweep trials');
        end
        title('Left lick rate (Hz)');
        
        subplot(2,6,2+(kk-1)*2); hold on;
        y=nRightUpsweep(:,kk);
        plot(nedges,y,col,'LineWidth',2);
        plot([0 0],[0 12],'k--','LineWidth',1); xlim([-3 5]); ylim([0 12]);
        title('Right lick rate (Hz)');
        
        subplot(2,6,7+(kk-1)*2); hold on;
        y=nLeftDownsweep(:,kk);
        plot(nedges,y,col,'LineWidth',2);
        plot([0 0],[0 12],'k--','LineWidth',1); xlim([-3 5]); ylim([0 12]);
        if kk==1
            ylabel('Downsweep trials');
        end
        xlabel('Time from cue (s)');
        
        subplot(2,6,8+(kk-1)*2); hold on;
        y=nRightDownsweep(:,kk);
        plot(nedges,y,col,'LineWidth',2);
        plot([0 0],[0 12],'k--','LineWidth',1); xlim([-3 5]); ylim([0 12]);
    end
    
    set(gcf,'Position',[40 40 1400 700]);  %laptop
    set(gcf, 'PaperPositionMode', 'auto');
    print(gcf, '-r0', [savefigpath subject '_' startDate(9:10) startDate(1:2) startDate(4:5) '_' scenarioName '_licks'], '-dtiff'); %tiff format
    saveas(gcf, [savefigpath subject '_' startDate(9:10) startDate(1:2) startDate(4:5) '_' scenarioName '_licks'], 'fig'); %fig format
end

%% ----- duration of the trials
if (plotFig4)
    interTrialDur=diff(startexptTime);
    
    figure;
    
    subplot(2,1,1);
    plot(1:numel(interTrialDur),interTrialDur,'ko');
    xlabel('Trial');
    ylabel('Time from cue to next cue');
    
    edges=[floor(min(interTrialDur)):0.2:ceil(max(interTrialDur))];
    n=histc(interTrialDur,edges);
    subplot(2,2,3);
    bar(edges,n,'histc');
    xlabel('Time from cue to next cue (s)');
    ylabel('Occurrence');
    xlim([edges(1) edges(end)]);
    title('All trials');

    n=histc(interTrialDur-firstRespTime(1:end-1)',edges);
    subplot(2,2,4);
    bar(edges,n,'histc');
    xlabel('Time from first response to next cue (s)');
    ylabel('Occurrence');
    xlim([edges(1) edges(end)]);
    title('All trials');
    
    set(gcf,'Position',[40 40 800 800]);  %laptop
    set(gcf, 'PaperPositionMode', 'auto');
    print(gcf, '-r0', [savefigpath subject '_' startDate(9:10) startDate(1:2) startDate(4:5) '_' scenarioName '_trialdur'], '-dtiff'); %tiff format
    saveas(gcf, [savefigpath subject '_' startDate(9:10) startDate(1:2) startDate(4:5) '_' scenarioName '_trialdur'], 'fig'); %fig format
end

%% ----- consecutive trials with the same stimulus
if (plotFig5)
    %do run-length encoding to see how many consecutive cues of same kind
    x=trialMask.upsweep;
    len=diff([0 find(x(1:end-1) ~= x(2:end)) length(x)]);
    val=x([find(x(1:end-1) ~= x(2:end)) length(x)]);
    
    figure;
    subplot(2,1,1); hold on;
    if val(1)==1 %upsweep
        plot([1:sum(val==1)],len(val==1),'ro','MarkerSize',10);
        plot(0.5+[1:sum(val==0)],len(val==0),'bo','MarkerSize',10);
    else
        plot([1:sum(val==0)],len(val==0),'bo','MarkerSize',10);
        plot(0.5+[1:sum(val==1)],len(val==1),'ro','MarkerSize',10);
    end
    xlabel('Trials (in batches, delineated by consecutive cues)');
    ylabel('Length of the batch');
    xlim([0 ceil(numel(val)/2)]);
    
    edges=[-0.5+min(len(val==1)):1:max(len(val==1))+0.5];
    n=histc(len(val==1),edges);
    subplot(2,2,3);
    bb=bar(edges,n,'histc');
    set(bb,'FaceColor','r');
    xlabel('Length of trial batches');
    ylabel('Occurrence');
    xlim([edges(1) edges(end)]);
    title('Upsweep');

    edges=[-0.5+min(len(val==0)):1:max(len(val==0))+0.5];
    n=histc(len(val==0),edges);
    subplot(2,2,4);
    bar(edges,n,'histc');
    xlabel('Length of trial batches');
    ylabel('Occurrence');
    xlim([edges(1) edges(end)]);
    title('Downsweep');
    
    set(gcf,'Position',[40 40 800 800]);  %laptop
    set(gcf, 'PaperPositionMode', 'auto');
    print(gcf, '-r0', [savefigpath subject '_' startDate(9:10) startDate(1:2) startDate(4:5) '_' scenarioName '_consecstim'], '-dtiff'); %tiff format
    saveas(gcf, [savefigpath subject '_' startDate(9:10) startDate(1:2) startDate(4:5) '_' scenarioName '_consecstim'], 'fig'); %fig format
end

%% ----- save analysis
save([newroot_dir behavFile(1:end-4)],'subject','startDate',...
    'hit_miss','currSet','switchTrial','currTrial','startexptTime',...
    'firstRespTime','firstLickTime',...
    'nLeftUpsweep','nRightUpsweep','nLeftDownsweep','nRightDownsweep','nedges',...
    'lickleftTime','lickrightTime','lickTime',...
    'trialMask','blockMask');